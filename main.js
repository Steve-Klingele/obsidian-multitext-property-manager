/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => PropertyValueManagerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  showRibbonIcon: true,
  enableDebugLogging: false,
  showModifiedFilesList: true,
  confirmBeforeDelete: true
};
var PropertyValueManagerPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.ribbonIconEl = null;
  }
  async onload() {
    await this.loadSettings();
    if (this.settings.showRibbonIcon) {
      this.addRibbonIconEl();
    }
    this.addCommand({
      id: "manage-property-values",
      name: "Manage multitext properties",
      callback: () => {
        new PropertyValueManagerModal(this.app, this.settings).open();
      }
    });
    this.addSettingTab(new PropertyValueManagerSettingTab(this.app, this));
    if (this.settings.enableDebugLogging) {
      console.log("Property Value Manager plugin loaded");
    }
  }
  onunload() {
    if (this.settings.enableDebugLogging) {
      console.log("Property Value Manager plugin unloaded");
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    if (this.settings.showRibbonIcon && !this.ribbonIconEl) {
      this.addRibbonIconEl();
    } else if (!this.settings.showRibbonIcon && this.ribbonIconEl) {
      this.ribbonIconEl.remove();
      this.ribbonIconEl = null;
    }
  }
  addRibbonIconEl() {
    this.ribbonIconEl = this.addRibbonIcon("list-checks", "Manage Multitext Properties", () => {
      new PropertyValueManagerModal(this.app, this.settings).open();
    });
  }
};
var PropertyValueManagerSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Multitext Property Manager Settings" });
    new import_obsidian.Setting(containerEl).setName("Show ribbon icon").setDesc("Display the plugin icon in the left sidebar").addToggle((toggle) => toggle.setValue(this.plugin.settings.showRibbonIcon).onChange(async (value) => {
      this.plugin.settings.showRibbonIcon = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Enable debug logging").setDesc("Show detailed debug information in the console (for troubleshooting)").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableDebugLogging).onChange(async (value) => {
      this.plugin.settings.enableDebugLogging = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Show modified files list").setDesc("Display a list of files that were modified after deleting a property value").addToggle((toggle) => toggle.setValue(this.plugin.settings.showModifiedFilesList).onChange(async (value) => {
      this.plugin.settings.showModifiedFilesList = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Confirm before delete").setDesc("Show confirmation dialog before deleting property values").addToggle((toggle) => toggle.setValue(this.plugin.settings.confirmBeforeDelete).onChange(async (value) => {
      this.plugin.settings.confirmBeforeDelete = value;
      await this.plugin.saveSettings();
    }));
  }
};
var PropertyValueManagerModal = class extends import_obsidian.Modal {
  constructor(app, settings) {
    super(app);
    this.selectedProperty = null;
    this.propertyData = /* @__PURE__ */ new Map();
    this.settings = settings;
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("property-value-manager-modal");
    contentEl.createEl("h2", { text: "Multitext Property Manager" });
    const loadingEl = contentEl.createEl("p", { text: "Scanning vault for multitext properties..." });
    await this.scanVaultProperties();
    loadingEl.remove();
    if (this.propertyData.size === 0) {
      contentEl.createEl("p", { text: "No multitext properties found in vault." });
      return;
    }
    this.renderPropertyList();
  }
  async scanVaultProperties() {
    const files = this.app.vault.getMarkdownFiles();
    if (this.settings.enableDebugLogging) {
      console.log("Property Value Manager: Scanning vault...");
      console.log("Total files:", files.length);
    }
    const multitextProperties = /* @__PURE__ */ new Set();
    try {
      const configDir = this.app.vault.adapter.getBasePath ? this.app.vault.adapter.getBasePath() : this.app.vault.adapter.getResourcePath("");
      if (this.settings.enableDebugLogging) {
        console.log("Vault config dir:", configDir);
        console.log("Reading from path:", this.app.vault.configDir + "/types.json");
      }
      const typesPath = this.app.vault.configDir + "/types.json";
      const typesContent = await this.app.vault.adapter.read(typesPath);
      const typesData = JSON.parse(typesContent);
      if (this.settings.enableDebugLogging) {
        console.log("Loaded types.json successfully");
        console.log("Types data:", typesData);
      }
      if (typesData.types) {
        if (this.settings.enableDebugLogging) {
          console.log("Types object:", typesData.types);
        }
        for (const [propName, propType] of Object.entries(typesData.types)) {
          if (this.settings.enableDebugLogging) {
            console.log(`  Property: ${propName}, Type: ${propType}`);
          }
          if (propType === "multitext") {
            multitextProperties.add(propName);
            if (this.settings.enableDebugLogging) {
              console.log(`    -> Added ${propName} as multitext`);
            }
          }
        }
      }
    } catch (error) {
      console.error("Error reading types.json:", error);
    }
    if (this.settings.enableDebugLogging) {
      console.log("Multitext properties from types.json:", Array.from(multitextProperties));
    }
    for (const file of files) {
      const cache = this.app.metadataCache.getFileCache(file);
      if (!(cache == null ? void 0 : cache.frontmatter))
        continue;
      for (const [key, value] of Object.entries(cache.frontmatter)) {
        if (!multitextProperties.has(key))
          continue;
        if (value === null || value === void 0)
          continue;
        if (!this.propertyData.has(key)) {
          this.propertyData.set(key, {
            property: key,
            values: /* @__PURE__ */ new Set(),
            files: /* @__PURE__ */ new Map()
          });
        }
        const propData = this.propertyData.get(key);
        let values = Array.isArray(value) ? value : [value];
        values = values.filter((v) => v !== null && v !== void 0);
        for (const val of values) {
          const stringVal = String(val);
          propData.values.add(stringVal);
          if (!propData.files.has(stringVal)) {
            propData.files.set(stringVal, []);
          }
          propData.files.get(stringVal).push(file);
        }
      }
    }
    if (this.settings.enableDebugLogging) {
      console.log(`Found ${this.propertyData.size} multitext properties with values`);
      const statusData = this.propertyData.get("Status");
      if (statusData) {
        console.log("Status property found!");
        console.log(`  Values (${statusData.values.size}):`, Array.from(statusData.values).sort());
      } else {
        console.log("Status property NOT found - check if it exists in types.json");
      }
    }
  }
  renderPropertyList() {
    const { contentEl } = this;
    const existingContainer = contentEl.querySelector(".property-container");
    if (existingContainer)
      existingContainer.remove();
    const container = contentEl.createDiv({ cls: "property-container" });
    const selectorDiv = container.createDiv({ cls: "property-selector" });
    selectorDiv.createEl("h3", { text: "Select a property:" });
    const propertyList = selectorDiv.createDiv({ cls: "property-list" });
    const sortedProperties = Array.from(this.propertyData.entries()).sort(
      (a, b) => a[0].localeCompare(b[0])
    );
    for (const [propName, propData] of sortedProperties) {
      const propItem = propertyList.createDiv({ cls: "property-item" });
      if (propName === this.selectedProperty) {
        propItem.addClass("selected");
      }
      propItem.createEl("strong", { text: propName });
      propItem.createEl("span", { text: ` (${propData.values.size} values)`, cls: "property-count" });
      propItem.addEventListener("click", () => {
        propertyList.querySelectorAll(".property-item").forEach((el) => el.removeClass("selected"));
        propItem.addClass("selected");
        this.selectedProperty = propName;
        this.renderPropertyValues(propData);
      });
    }
    if (this.selectedProperty && this.propertyData.has(this.selectedProperty)) {
      this.renderPropertyValues(this.propertyData.get(this.selectedProperty));
    }
  }
  renderPropertyValues(propData) {
    var _a;
    const { contentEl } = this;
    const existingValuesContainer = contentEl.querySelector(".values-container");
    if (existingValuesContainer)
      existingValuesContainer.remove();
    const valuesContainer = contentEl.createDiv({ cls: "values-container" });
    valuesContainer.createEl("h3", { text: `Values for "${propData.property}":` });
    const valuesList = valuesContainer.createDiv({ cls: "values-list" });
    const sortedValues = Array.from(propData.values).sort((a, b) => a.localeCompare(b));
    for (const value of sortedValues) {
      const valueItem = valuesList.createDiv({ cls: "value-item" });
      const valueText = valueItem.createDiv({ cls: "value-text" });
      valueText.createEl("span", { text: value });
      const fileCount = ((_a = propData.files.get(value)) == null ? void 0 : _a.length) || 0;
      const countText = fileCount === 0 ? " (0 files - orphaned)" : ` (${fileCount} file${fileCount !== 1 ? "s" : ""})`;
      valueText.createEl("span", {
        text: countText,
        cls: fileCount === 0 ? "value-count orphaned" : "value-count"
      });
      const deleteBtn = valueItem.createEl("button", {
        text: "\xD7",
        cls: "value-delete-btn"
      });
      deleteBtn.addEventListener("click", async () => {
        await this.deletePropertyValue(propData.property, value, fileCount);
      });
    }
  }
  async deletePropertyValue(property, value, fileCount) {
    const propData = this.propertyData.get(property);
    if (!propData)
      return;
    const files = propData.files.get(value) || [];
    if (this.settings.confirmBeforeDelete) {
      const confirmed = await this.confirmDeletion(property, value, fileCount);
      if (!confirmed)
        return;
    }
    if (fileCount === 0) {
      new import_obsidian.Notice(`Removing orphaned value "${value}" from metadata`);
      propData.values.delete(value);
      propData.files.delete(value);
      this.renderPropertyList();
      new import_obsidian.Notice(`Removed orphaned value "${value}"`);
      return;
    }
    new import_obsidian.Notice(`Removing "${value}" from ${fileCount} file(s)...`);
    let updatedCount = 0;
    const modifiedFiles = [];
    for (const file of files) {
      try {
        await this.removeValueFromFile(file, property, value);
        updatedCount++;
        modifiedFiles.push(file);
      } catch (error) {
        console.error(`Error updating file ${file.path}:`, error);
      }
    }
    new import_obsidian.Notice(`Successfully removed "${value}" from ${updatedCount} file(s)`);
    if (this.settings.showModifiedFilesList && modifiedFiles.length > 0) {
      new ModifiedFilesModal(this.app, modifiedFiles, property, value).open();
    }
    this.propertyData.clear();
    await this.scanVaultProperties();
    this.renderPropertyList();
  }
  async confirmDeletion(property, value, fileCount) {
    return new Promise((resolve) => {
      const modal = new import_obsidian.Modal(this.app);
      modal.contentEl.createEl("h3", { text: "Confirm Deletion" });
      if (fileCount === 0) {
        modal.contentEl.createEl("p", {
          text: `Remove orphaned value "${value}" from the "${property}" property?`
        });
        modal.contentEl.createEl("p", {
          text: "This value exists in Obsidian's metadata but is not used in any files. Removing it will clean up your property dropdown suggestions.",
          cls: "mod-info"
        });
      } else {
        modal.contentEl.createEl("p", {
          text: `Are you sure you want to remove "${value}" from the "${property}" property in ${fileCount} file(s)?`
        });
        modal.contentEl.createEl("p", {
          text: "This action cannot be undone.",
          cls: "mod-warning"
        });
      }
      const buttonContainer = modal.contentEl.createDiv({ cls: "modal-button-container" });
      const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
      cancelBtn.addEventListener("click", () => {
        modal.close();
        resolve(false);
      });
      const confirmBtn = buttonContainer.createEl("button", {
        text: fileCount === 0 ? "Remove" : "Delete",
        cls: "mod-warning"
      });
      confirmBtn.addEventListener("click", () => {
        modal.close();
        resolve(true);
      });
      modal.open();
    });
  }
  async removeValueFromFile(file, property, valueToRemove) {
    const content = await this.app.vault.read(file);
    const lines = content.split("\n");
    let inFrontmatter = false;
    let frontmatterStart = -1;
    let frontmatterEnd = -1;
    let propertyLineIndex = -1;
    let isMultilineProperty = false;
    let propertyIndent = "";
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (line.trim() === "---") {
        if (!inFrontmatter) {
          inFrontmatter = true;
          frontmatterStart = i;
        } else {
          frontmatterEnd = i;
          break;
        }
        continue;
      }
      if (inFrontmatter) {
        const propertyMatch = line.match(/^(\s*)([^:]+):\s*(.*)$/);
        if (propertyMatch && propertyMatch[2].trim() === property) {
          propertyLineIndex = i;
          propertyIndent = propertyMatch[1];
          const valueContent = propertyMatch[3].trim();
          if (valueContent === "" || valueContent === "[" || valueContent === "|") {
            isMultilineProperty = true;
          } else {
            isMultilineProperty = false;
          }
        }
      }
    }
    if (propertyLineIndex === -1)
      return;
    if (isMultilineProperty) {
      const valuesToKeep = [];
      let i = propertyLineIndex + 1;
      while (i < frontmatterEnd) {
        const line = lines[i];
        const trimmed = line.trim();
        if (trimmed.startsWith("-")) {
          const val = trimmed.substring(1).trim();
          if (val !== valueToRemove) {
            valuesToKeep.push(line);
          }
          i++;
        } else if (trimmed === "" || !line.startsWith(propertyIndent + " ")) {
          break;
        } else {
          i++;
        }
      }
      const numLinesToRemove = i - propertyLineIndex;
      lines.splice(propertyLineIndex, numLinesToRemove);
      if (valuesToKeep.length > 0) {
        const newLines = [lines[propertyLineIndex - (numLinesToRemove - 1)] || `${propertyIndent}${property}:`];
        newLines.push(...valuesToKeep);
        lines.splice(propertyLineIndex, 0, ...newLines.slice(1));
      }
    } else {
      const line = lines[propertyLineIndex];
      const match = line.match(/^(\s*)([^:]+):\s*(.*)$/);
      if (match) {
        const indent = match[1];
        const propName = match[2];
        let valueContent = match[3].trim();
        if (valueContent.startsWith("[") && valueContent.endsWith("]")) {
          const arrayContent = valueContent.substring(1, valueContent.length - 1);
          const values = arrayContent.split(",").map((v) => v.trim()).filter((v) => v !== "");
          const filteredValues = values.filter((v) => v !== valueToRemove && v !== `"${valueToRemove}"` && v !== `'${valueToRemove}'`);
          if (filteredValues.length > 0) {
            lines[propertyLineIndex] = `${indent}${propName}: [${filteredValues.join(", ")}]`;
          } else {
            lines.splice(propertyLineIndex, 1);
          }
        } else if (valueContent === valueToRemove) {
          lines.splice(propertyLineIndex, 1);
        }
      }
    }
    const newContent = lines.join("\n");
    await this.app.vault.modify(file, newContent);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var ModifiedFilesModal = class extends import_obsidian.Modal {
  constructor(app, files, property, value) {
    super(app);
    this.files = files;
    this.property = property;
    this.value = value;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("modified-files-modal");
    contentEl.createEl("h2", { text: "Modified Files" });
    contentEl.createEl("p", {
      text: `Removed "${this.value}" from "${this.property}" in ${this.files.length} file(s):`
    });
    const filesList = contentEl.createDiv({ cls: "modified-files-list" });
    for (const file of this.files) {
      const fileItem = filesList.createDiv({ cls: "modified-file-item" });
      const link = fileItem.createEl("a", {
        text: file.path,
        cls: "modified-file-link"
      });
      link.addEventListener("click", async (e) => {
        e.preventDefault();
        await this.app.workspace.getLeaf().openFile(file);
        this.close();
      });
    }
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const closeBtn = buttonContainer.createEl("button", { text: "Close" });
    closeBtn.addEventListener("click", () => this.close());
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
